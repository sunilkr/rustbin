use std::{io::{BufReader, Result, Seek, SeekFrom}, fs::File};

use crate::types::{HeaderField, Header};

use self::{dos::DosHeader, file::FileHeader};

pub mod dos;
pub mod section;
pub mod file;
pub mod optional;

#[derive(Debug)]
pub struct PeImage{
    pub dos: HeaderField<DosHeader>,
    pub file: HeaderField<FileHeader>,
}

impl Header for PeImage {
    fn parse_file(f: &mut BufReader<File>, pos: u64) -> Result<Self> where Self: Sized {
        f.seek(SeekFrom::Start(pos))?;
        let dos_header = DosHeader::parse_file(f, pos)?;
        let mut new_pos = pos + dos_header.e_lfanew.value as u64;
        let file_header = FileHeader::parse_file(f, new_pos)?;

        Ok( Self {
            dos: HeaderField{value: dos_header, offset: pos, rva: pos},
            file: HeaderField { value: file_header, offset: new_pos, rva: new_pos }
        })
    }

    fn parse_bytes(bytes: &[u8], pos: u64) -> Result<Self> where Self: Sized {
        let dos_header = DosHeader::parse_bytes(&bytes, pos)?;
        let mut slice_start = pos + dos_header.e_lfanew.value as u64;
        let mut slice_end = slice_start + file::HEADER_LENGTH;
        let buf = &bytes[slice_start as usize..slice_end as usize];
        let file_header = FileHeader::parse_bytes(buf, slice_start)?;

        Ok( Self {
            dos: HeaderField{value: dos_header, offset: pos, rva: pos},
            file: HeaderField { value: file_header, offset: slice_start, rva: slice_start }
        })
    }

    fn is_valid(&self) -> bool {
        self.dos.value.is_valid()
    }

    fn length() -> usize {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use crate::types::Header;

    use super::PeImage;

    const  RAW_BYTES: [u8; 0x110] = [
        0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
        0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00,
        0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
        0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
        0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
        0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x93, 0x41, 0xA6, 0x47, 0xF2, 0x2F, 0xF5, 0x47, 0xF2, 0x2F, 0xF5, 0x47, 0xF2, 0x2F, 0xF5,
        0x4E, 0x8A, 0xBC, 0xF5, 0x4B, 0xF2, 0x2F, 0xF5, 0x2B, 0x86, 0x2E, 0xF4, 0x45, 0xF2, 0x2F, 0xF5,
        0x2B, 0x86, 0x2A, 0xF4, 0x51, 0xF2, 0x2F, 0xF5, 0x2B, 0x86, 0x2B, 0xF4, 0x4E, 0xF2, 0x2F, 0xF5,
        0x2B, 0x86, 0x2C, 0xF4, 0x44, 0xF2, 0x2F, 0xF5, 0x1C, 0x9A, 0x2E, 0xF4, 0x4E, 0xF2, 0x2F, 0xF5,
        0x47, 0xF2, 0x2E, 0xF5, 0xE0, 0xF2, 0x2F, 0xF5, 0x47, 0xF2, 0x2F, 0xF5, 0xC5, 0xF2, 0x2F, 0xF5,
        0x91, 0x86, 0x2D, 0xF4, 0x46, 0xF2, 0x2F, 0xF5, 0x52, 0x69, 0x63, 0x68, 0x47, 0xF2, 0x2F, 0xF5,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x05, 0x00,
        0xA5, 0xE6, 0xE4, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00
    ];

    #[test]
    fn parse_valid_header() {
        let pe = PeImage::parse_bytes(&RAW_BYTES, 0).unwrap();
        assert!(pe.dos.value.is_valid());
        assert_eq!(pe.dos.offset, 0);
        assert_eq!(pe.dos.rva, 0);
        assert!(pe.file.value.is_valid());
        assert_eq!(pe.file.offset, 0xf8);
        assert_eq!(pe.file.rva, 0xf8);
    }
}