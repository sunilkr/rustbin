use chrono::{DateTime, Utc};
use serde::Serialize;

use crate::pe::export::{Export, ExportDirectory};

use super::{hf_to_hfx, ByteEndian, HeaderFieldEx};

#[derive(Debug, Serialize)]
pub struct ExportEx {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<HeaderFieldEx<String>>,
    pub address: HeaderFieldEx<u32>,
    pub ordinal: HeaderFieldEx<u16>,
}

impl From<&Export> for ExportEx {
    fn from(value: &Export) -> Self {
        Self { 
            name: if let Some(name) = &value.name {
                Some( HeaderFieldEx { 
                    raw: name.value.as_bytes().to_vec(), 
                    value: name.clone(), 
                })
            } else {None},

            address: hf_to_hfx(&value.address, ByteEndian::LE),
            ordinal: hf_to_hfx(&value.ordinal, ByteEndian::LE),
        }
    }
}


#[derive(Debug, Serialize)]
pub struct ExportDirectoryEx {
    pub charatristics: HeaderFieldEx<u32>,
    pub timestamp: HeaderFieldEx<DateTime<Utc>>,
    pub major_version: HeaderFieldEx<u16>,
    pub minor_version: HeaderFieldEx<u16>,
    pub name_rva: HeaderFieldEx<u32>,
    pub base: HeaderFieldEx<u32>,
    pub number_of_functions: HeaderFieldEx<u32>,
    pub number_of_names: HeaderFieldEx<u32>,
    pub address_of_functions: HeaderFieldEx<u32>,
    pub address_of_names: HeaderFieldEx<u32>,
    pub address_of_name_ordinals: HeaderFieldEx<u32>,
    pub name: HeaderFieldEx<String>,
    pub exports: Vec<ExportEx>,
}

impl From<&ExportDirectory> for ExportDirectoryEx {
    fn from(value: &ExportDirectory) -> Self {
        Self { 
            charatristics: hf_to_hfx(&value.charatristics, ByteEndian::LE), 
            timestamp: HeaderFieldEx { 
                raw: ((value.timestamp.value.timestamp_millis() / 1000) as u32)
                    .to_le_bytes()
                    .to_vec(),
                value: value.timestamp.clone()
            },
            major_version: hf_to_hfx(&value.major_version, ByteEndian::LE),
            minor_version: hf_to_hfx(&value.minor_version, ByteEndian::LE),
            name_rva: hf_to_hfx(&value.name_rva, ByteEndian::LE),
            base: hf_to_hfx(&value.base, ByteEndian::LE),
            number_of_functions: hf_to_hfx(&value.number_of_functions, ByteEndian::LE),
            number_of_names: hf_to_hfx(&value.number_of_names, ByteEndian::LE),
            address_of_functions: hf_to_hfx(&value.address_of_functions, ByteEndian::LE),
            address_of_names: hf_to_hfx(&value.address_of_names, ByteEndian::LE),
            address_of_name_ordinals: hf_to_hfx(&value.address_of_name_ordinals, ByteEndian::LE),
            name: HeaderFieldEx{ raw: value.name.value.as_bytes().to_vec(), value: value.name.clone() },
            exports: value.exports
                .iter()
                .map(|ex| ExportEx::from(ex))
                .collect(),
        }
    }
}


#[cfg(test)]
mod tests {
    use crate::{pe::{export::ExportDirectory, section::parse_sections}, types::Header, utils::FragmentReader};

    use super::ExportDirectoryEx;

    const SECTION_POS: u64 = 0x200;
    const SECTION_COUNT: u16 = 6;
    const RAW_SECTION_BYTES: [u8; 240] = [
        0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x54, 0xAC, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0x00, 0xAE, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
        0xEC, 0x64, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
        0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0xB8, 0x39, 0x00, 0x00, 0x00, 0x30, 0x01, 0x00,
        0x00, 0x16, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC0, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
        0xB8, 0x08, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x2E, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
        0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00, 0xA8, 0x05, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00,
        0x24, 0x05, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x3E, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42
    ];

    const EXPORT_OFFSET: u64 = 0x10f30;
    const RAW_EXPORT_BYTES: [u8; 144] = [
        0x00, 0x00, 0x00, 0x00, 0x57, 0xBB, 0x3B, 0x56, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x1D, 0x01, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x58, 0x1D, 0x01, 0x00,
        0x60, 0x1D, 0x01, 0x00, 0x68, 0x1D, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00,
        0x81, 0x1D, 0x01, 0x00, 0x8F, 0x1D, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x6C, 0x69, 0x62, 0x67,
        0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x32, 0x2E, 0x30, 0x2D, 0x30, 0x2E, 0x64, 0x6C, 0x6C,
        0x00, 0x67, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x67,
        0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x5F, 0x77, 0x69, 0x74,
        0x68, 0x5F, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x5F, 0x6D, 0x75, 0x74,
        0x65, 0x78, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn serialize_exports() {
        let sections = parse_sections(&RAW_SECTION_BYTES, SECTION_COUNT, SECTION_POS).unwrap();
        let mut exports = ExportDirectory::parse_bytes(RAW_EXPORT_BYTES.to_vec(), EXPORT_OFFSET).unwrap();
        let mut reader = FragmentReader::new(RAW_EXPORT_BYTES.to_vec(), EXPORT_OFFSET);
        exports.parse_exports(&sections, &mut reader).unwrap();

        let full_exports = ExportDirectoryEx::from(&exports);

        assert_eq!(full_exports.timestamp.raw, vec![87, 187, 59, 86]);
        assert_eq!(full_exports.address_of_functions.raw, vec![88, 29, 1, 0]);
    }
}